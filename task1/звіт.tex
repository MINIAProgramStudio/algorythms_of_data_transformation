\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[ukrainian]{babel}
\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref}
\title{Алгоритми перетворення інформації. Завдання 1, звіт}
\author{Михайло Голуб}
\usepackage{graphicx}
\graphicspath{ {./img/} }

\def\code#1{\texttt{#1}}

\begin{document}
\maketitle
\newpage

\textbf{Реалізація функції \code{encode(in\_bytes)} для RLE:}
\\\indent

На вхід приймається масив байтів \code{in\_bytes}. Створюються пусті масиви байтів \code{output} та \code{bufer}.\\\indent 
Для кожного байту з вхідного масиву:
\begin{enumerate}
\item \textbf{Перевірка на переповнення буфера:}\\
Якщо довжина буферу більша за 127 і буфер містить різні символи -- додати службовий байт "переписати 128 символів" до вихідного масиву (дялі -- ВМ), переписати буфер до ВМ та очистити буфер;\\\\
Якщо довжина буферу рівна 129 і буфер містить однакові символи -- додати службовий байт "повторення 129 разів" і перший байт з буфера до Вихідного масиву та очистити буфер.
\item \textbf{Перевірка на закінчення послідовності різних байтів:}\\
Якщо довжина буфера більша за 1 і поточний обраний байт рівний останньому байту буфера, але не рівний передостанньому -- завершено послідовність різних байтів. До ВМ додається службовий байт виду \code{0*******}, де значення молодщих бітів плюс 1 -- кількість байтів які треба переписати декодеру після даного службового байту. Після службового байту, до ВМ додається буфер, після чого буфер очищується.
\item \textbf{Перевірка на закінчення послідовності однакових байтів:}\\
Якщо довжина буфера більша за 1 і поточний обраний байт не рівний останньому байту буфера і останній та передостанній байти буфера рівні -- завершено послідовність однакових байтів. До ВМ додається службовий байт виду \code{1*******}, де значення молодших бітів плюс 2 -- кількість повторень наступного байту які має зробити декодер. Після службового байту, до ВМ додається перший байт з буфера, після чого буфер очищується.
\item \textbf{Додати поточний байт до буфера}
\end{enumerate}

Після завершення циклу, якщо буфер не порожній, виконуються кроки аналогічні крокам 2 та 3.\\\indent
Функція повертає сформований вихідний масив байтів \code{output}\\\indent
\newpage

\textbf{Реалізація функції \code{decode(in\_bytes)} для RLE:}
\\\indent

На вхід приймається масив байтів \code{in\_bytes}. Створюється пустий масив байтів \code{output} та змінна \code{pointer}
Доки значення \code{pointer} менше за довжину вхідного масиву:
\begin{enumerate}
\item Якщо байт на позиції \code{pointer} у вхідному масиві більший за 127 -- записати у ВМ \code{байт-126} разів байт на позиції \code{pointer+1}. Збільшити \code{pointer} на 2.
\item Інакше -- переписати наступні \code{байт+1} байтів у ВМ. Збільшити \code{pointer} на байт+2.
\end{enumerate}
Функція повертає сформований вихідний масив байтів.\\\indent

\textbf{Взаємодія з реалізованими функціями RLE:}\\\indent

Функції \code{encode} та \code{decode} знаходяться у файлах \code{rle\_encode.py} та\\ \code{rle\_decode.py}. При запуску файлу з бажаною функцією як головного файлу (відкрити за допомогою інтерпритатора) у консоль виводяться короткі підказки та користувач може ввести бажані шляхи до початкового файлу та кінцевого результату.\\\indent
Також створено програму \code{rle\_main.py} яка приймає на вхід команди виду \code{encode;source;destination} та \code{decode;source;destination} усі символи (у т.ч. пробіли) після ; будуть вважатись частиною шляху.\\\indent
Приклади правильного використання команд:\\
\code{encode;file.txt;} -- вихідний файл буде мати шлях file.txt.rle\\
\code{decode;file.txt.rle;} -- вихідний файл буде мати шлях file.txt\\
\code{encode;file.txt;example.com}\\
\code{decode;example.com;file.txt}\\\indent

\textbf{Тестування RLE:}\\\indent

Програму протестовано на декількох різних файлах: текстових, зображеннях, коротких відео та документах .docs:
\begin{itemize}
\item Текстовий файл що містив Гамлета зменшився на менш ніж 900 байтів при початковому розмірі 187 КБайт.
\item Текстові файли стереолітографічного (.stl) змісту зменшились на 5-10\% через наявність певних ділянок однакових цифер в числах
\item Файли з короткими відео збільшились на 1-2%, оскільки вже мають якесь певне кодування та повторення байтів в них -- рідкість
\end{itemize}
\end{document}