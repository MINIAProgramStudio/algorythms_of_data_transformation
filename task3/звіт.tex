\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[ukrainian]{babel}
\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref}
\title{Алгоритми перетворення інформації. Завдання 3, звіт}
\author{Михайло Голуб}
\usepackage{graphicx}
\graphicspath{ {./img/} }

\def\code#1{\texttt{#1}}

\begin{document}
\maketitle
\newpage

\textbf{Реалізація класу \code{BitArray}:}\\\indent

На відміну від аналогічного класу в завданні 2, цей клас використовує вбудований клас \code{bytearray} що є мутабельним. 
Це дозволяє пришвидшити роботу шляхом зміни байтів, не перестворюючи клас \code{bytes} кожного разу. 
Також було додано більше методів, які необхідні для роботи інших класів та функцій.\\\indent
Перелік методів класу \code{BitArray}:
\begin{itemize}
    \item \textbf{\code{\_\_init\_\_(in\_bytes, bit\_pointer)}} -- ініціалізує клас, на вхід приймає список байтів та вказівник на біт, що не використовується в останньому байті (якщо вказівник рівний 8, значить останній байт використовується повністю);
    \item \textbf{\code{\_\_len\_\_()}} -- повертає довжину файлу;
    \item \textbf{\code{\_\_str\_\_()}} -- повертає текстову репрезентацію збереженого бітового рядка;
    \item \textbf{\code{\_\_rshift\_\_(other)}} -- дозволяє робити \code{BitArray$>>$число}, знищує перші *число* біт в рядку;
    \item \textbf{\code{\_\_lshift\_\_(other)}} -- дозволяє робити \code{BitArray$<<$число}, додає *число* нулів в початок рядка;
    \item \textbf{\code{\_\_repr\_\_()}} -- викликає str(BitArray). Існує для відображення бітового рядка як бітового рядка, а не класа з адресою, в функціях що виводять помилки чи текст в консоль;
    \item \textbf{\code{concat(right)}} -- повертає бітовий рядок, що є результатом конкатинації поточного рядка з іншим;
    \item \textbf{\code{self\_concat(right)}} -- конкатинує до поточного бітового рядка інший рядок. Пришвидшує роботу конкатинації, якщо не потрібно зберігати рядок до конкатинації;
    \item \textbf{\code{\_\_eq\_\_(other)}} -- дозволяє робити \code{BitArray1 == BitArray2};
    \item \textbf{\code{\_\_hash\_\_()}} -- визначає геш представника класу, як геш його байтів. Метод необхідний для запису представника класу як індекса таблиць кодування та декодування;
    \item \textbf{\code{\_\_getitem\_\_(key)}} -- дозволяє отримати біт, або підрядок бітів, на певній позиції шляхом виконання \code{BitArray[i]} та \code{BitArray[i:j]};
    \item \textbf{\code{get\_bit(key)}} -- повертає біт на позиції \code{key}, дещо швидший за \code{BitArray[key]};
    \item \textbf{\code{append\_bit(bit)}} -- дописує один біт в кінець бітового рядка;
    \item \textbf{\code{copy()}} -- повертає представник класу ідентичний поточному представнику.\\\indent
\end{itemize}

\textbf{Реалізація класу \code{BitSequenceFile}:}\\\indent

Реалізація класу \code{BitSequenceFile} аналогічна реалізації в завданні 2, з виправленням деяких помилок.\\\indent

\textbf{Реалізація класу \code{ByteCounter}:}\\\indent

Мета класу -- порахувати байти. Отримує на вхід шлях файла, рахує байти в ньому та повертає словник виду \code{\{byte: n\_encountered\}}. За потреби, результат роботи лічильника бути представлений в консолі у вигляді таблиці

\textbf{Реалізація класу \code{HuffmanTree}:}\\\indent

Клас на вхід приймає \code{source}. Якщо це представник класу \code{ByteCounter} -- будується дерево Хаффмана на основі лічильника. Інакше -- клас створюється пустим та не готовим до роботи (необхідно для побудови дерева декодером).\\\indent
Перелік методів класу \code{HuffmanTree}:
\begin{itemize}
    \item \textbf{\code{\_\_init\_\_(source)}} -- ініціалізує клас, якщо отримано лічильник -- будує дерево;
    \item \textbf{\code{build(recount = True)}} -- будує дерево, якщо \code{recount} -- викликає перерахунок лічильника. Дерево будується наступним чином:\\\indent
        Cтворюється два словники виду \code{key: \{n\_encountered, left\_child\_key, right\_child\_key, parent\_key\}}, один словник містить усі вершини дерева, другий містить вершини що ще не були з'єднанні. \code{key} відповідає значенню байта для листків, або лежить в діапазоні 256-511 для вершин рощгалужень.\\\indent
        Допоки існують необ'єднанні вершини -- обрати дві необ'єднанні вершини з найменшою сумарною вагою та об'єднати. \code{key} останньої вершини запам'ятати як \code{self.tree\_key}.\\\indent
        Викликати \code{create\_encoding\_lookup} та \code{create\_decoding\_lookup};
    \item \textbf{\code{create\_encoding\_lookup()}} -- для кожного байта в списку вершин будує маршрут до кореня, шляхом переходу до батьківських вершин. Запам'ятовує бітовий рядок маршрута в словнику \code{encoding\_lookup} виду \code{\{byte: BitArray\}}. Байти що не зустрічались жодного разу у словнику видаляються;
    \item \textbf{\code{encode(object)}} -- побайтово знаходить відповідний байту бітовий рядок в \code{encoding\_lookup}. Повертає бітовий рядок що відповідає коду Хаффмана для усіх вхідних байтів;
    \item \textbf{\code{create\_decoding\_lookup()}} -- розвертає \code{encoding\_lookup} для утворення \code{decoding\_lookup} вигляду \code{\{BitArray: byte\}};
    \item \textbf{\code{decode(bit\_array, prog = False)}} -- декодує бітовий рядок. Якщо \code{prog} -- виводить прогресбар. Декодер побітово записує вхідний рядок в буфер (що є представником класу BitArray), якщо буфер є ключем в \code{decoding\_lookup} -- записує відповідний байт у вихідний \code{bytearray}. Після обробки усіх бітів -- повертає масив байтів;
    \item \textbf{\code{store()}} -- зберігає дерево у бітовий рядок наступного виду: перший байт -- кількість розгалужень у дереві, наступні 4 $\cdot$ *кількість розгалужень* байтів містять \code{key} лівої дитини (в двох перших байтах) та правої дитини (в тертьому та четвертому байтах). Теоретично можна вмістити ключі дітей в 18 біт, але усі спроби це реалізувати були невдалими.
\end{itemize}

\textbf{Реалізація кодування файлів:}\\\indent

На вхід приймається шлях файлу, бажаний шлях закодованого файлу (якщо такий відсутній, до поточного шляху файла дописується \code{.huff}) та розмір кроку з яким читати файл. Рахується кількість байтів у файлі, створюється дерево, дерево зберігається через \code{store()} в перших байтах файла, після чого файл читається та кодується кроками (за замовчуванням 1024 байта), результат кодування кроку одразу ж записується в файл (якщо файл не кратний довжині кроку -- останній крок буде коротшим, щоб це врахувати). Після кодування додається ще один байт, в якому записано вказівник на перший невикористаний біт в останньому байті, оскільки довжина закодованої бітової послідовності може бути не кратна восьми.

\textbf{Реалізація декодування файлів:}\\\indent

На вхід приймається шлях файлу, бажаний шлях декодованого файлу (якщо такий відсутній, з поточного шляху файла видаляється \code{.huff} (звісно ж, якщо це закінчення там присутнє)). Декодер читає кількість розгалужень в першому байті, читає інформацію про розгалуження в наступних 4 $\cdot$ *кількість розгалужень* байтах та записує її в список вершин, ходить по кожному розгалуженню і прописує його дітям \code{key} батька, якщо дитина це байт -- створює його у списку вершин, шукає корінь, записує список вершин та корінь в дерево та запускає \code{create\_encoding\_lookup()} і \code{create\_decoding\_lookup()}. Після цього читається вказівник у останньому байті, читається бітовий рядок між метаданими на початку файлу та останнім байтом, цей бітовий рядок декодується та результат записується в файл.\\\indent

\newpage
\textbf{Аналіз метаданих:}\\\indent

В завданні наведено приклад метаданих що завжди займає 1024 байти. Імплементований варіант в найгіршому випадку використовує 2 байти + 4 байти на кожне розгалуження (для алфавіту довжиною 256 кількість розгалужень 255), тобто 1020 байтів. Для текстових файлів цей показник ближчий до 400 байт.\\\indent
Якщо ж використовувати на кожне розгалуження не 4 байти, а 18 біт запропонованого варіанту, то в найгіршому випадку буде використовуватись 575 байт 6 біт.\\\indent

\textbf{Аналіз стиснення:}\\\indent

Для аналізу стиснення обрано наступні типи файлів: \code{.txt, .stl, .jpg, .mp3, .pdf, .mp4}. Обрано по 10 файлів для кожного типу. Оскільки обрані файли мають розміри значно більші за 1КБ (максимальний розмір метаданих), то коефіцієнт стиснення завжди буде рахуватись без відкидання метаданих з довжини файлу. Вказані відсоткові значення -- відношення закодованого розміру файлу до некодованого\\\indent
Стиснення \code{.jpg} в середньому відсутнє. В найкращому випадку -- 85.4\% (чорний текст на білому фоні), в найгіршому -- 118.4\% (відносно малий розмір файлу, кавун на білому фоні).\\\indent
Стиснення \code{.mp3} в середньому  99.09\%. В найкращому випадку -- 97.7\%. В найгіршому -- 99.8\%.\\\indent
Стиснення \code{.mp4} в середньому відсутнє. В найращому випадку -- 99.8\%. В найгіршому -- 100.1\%.\\\indent
Стиснення \code{.pdf} в середньому 99.34\%. В найкращому випадку -- 95.9\% (текстовий \code{.pdf}). В найгіршому -- 99.9\%.\\\indent
Стиснення \code{.stl} в середньому 74.27\%. В найкращому випадку -- 52.3\%. В найгіршому -- 91.3\%\\\indent
Стиснення \code{.txt} в середньому 59.83\%. В найкращому випадку -- 55.4\% (Володар перстнів, перша книга). В найгіршому -- 66.3\% (конфігураційний файл гри Minecraft).\\\indent
Ознайомитись з пофайловими результатами аналізу стиснення можна у файлі \code{files/test\_log.txt}\\\indent

\textbf{Висновки з результатів аналізу стиснення:}\\\indent
\begin{itemize}
    \item Найкраще стискаються текстові файли з природнім текстом, оскільки вони не використовують значну частину кодів символів, а наявні символи мають значно різні частоти.
    \item Найгірше стиснений текстовий файл, конфігураційний файл гри Minecraft містить багато символів (в основному цифр) з однаковою частотою, через це його стиснення було менш ефективним.
    \item Найгірше стискаються, а точніше не стискаються, типи файлів що вже були стиснуті. У їх числі MPEG, JPEG та PDF файли які використовують дуже ефективне стиснення самі по собі. Серед них найкраще стиснулось зображення чорного тексту на білому фоні.
    \item Створене програмне забезпечення не ефективно застосовувати на файлах розміром менше 10КБ, оскільки якщо файл має високий рівень випадковості байтів, то він буде стиснутий недостатньо, щоб вихідний файл був менший ніж початковий.\\\indent
\end{itemize}


\textbf{Посилання на код на GitHub:}\\
\code{https://github.com/MINIAProgramStudio/algorythms\_of\_data\_transformation/tree/main/task3}
\end{document}