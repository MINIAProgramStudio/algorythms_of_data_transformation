\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[ukrainian]{babel}
\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref}
\title{Алгоритми перетворення інформації. Завдання 3, звіт}
\author{Михайло Голуб}
\usepackage{graphicx}
\graphicspath{ {./img/} }

\def\code#1{\texttt{#1}}

\begin{document}
\maketitle
\newpage

\textbf{Реалізація класу \code{BitArray}:}\\\indent

На відміну від аналогічного класу в завданні 2, цей клас використовує вбудований клас \code{bytearray} що є мутабельним. 
Це дозволяє пришвидшити роботу шляхом зміни байтів, не перестворюючи клас \code{bytes} кожного разу. 
Також було додано більше методів, які необхідні для роботи інших класів та функцій.\\\indent
Перелік методів класу \code{BitArray}:
\begin{itemize}
    \item \textbf{\code{\_\_init\_\_(in\_bytes, bit\_pointer)}} -- ініціалізує клас, на вхід приймає список байтів та вказівник на біт, що не використовується в останньому байті (якщо вказівник рівний 8, значить останній байт використовується повністю);
    \item \textbf{\code{\_\_len\_\_()}} -- повертає довжину файлу;
    \item \textbf{\code{\_\_str\_\_()}} -- повертає текстову репрезентацію збереженого бітового рядка;
    \item \textbf{\code{\_\_rshift\_\_(other)}} -- дозволяє робити \code{BitArray$>>$число}, знищує перші *число* біт в рядку;
    \item \textbf{\code{\_\_lshift\_\_(other)}} -- дозволяє робити \code{BitArray$<<$число}, додає *число* нулів в початок рядка;
    \item \textbf{\code{\_\_repr\_\_()}} -- викликає str(BitArray). Існує для відображення бітового рядка як бітового рядка, а не класа з адресою, в функціях що виводять помилки чи текст в консоль;
    \item \textbf{\code{concat(right)}} -- повертає бітовий рядок, що є результатом конкатинації поточного рядка з іншим;
    \item \textbf{\code{self\_concat(right)}} -- конкатинує до поточного бітового рядка інший рядок. Пришвидшує роботу конкатинації, якщо не потрібно зберігати рядок до конкатинації;
    \item \textbf{\code{\_\_eq\_\_(other)}} -- дозволяє робити \code{BitArray1 == BitArray2};
    \item \textbf{\code{\_\_hash\_\_()}} -- визначає геш представника класу, як геш його байтів. Метод необхідний для запису представника класу як індекса таблиць кодування та декодування;
    \item \textbf{\code{\_\_getitem\_\_(key)}} -- дозволяє отримати біт, або підрядок бітів, на певній позиції шляхом виконання \code{BitArray[i]} та \code{BitArray[i:j]};
    \item \textbf{\code{get\_bit(key)}} -- повертає біт на позиції \code{key}, дещо швидший за \code{BitArray[key]};
    \item \textbf{\code{append\_bit(bit)}} -- дописує один біт в кінець бітового рядка;
    \item \textbf{\code{copy()}} -- повертає представник класу ідентичний поточному представнику.\\\indent
\end{itemize}

\textbf{Реалізація класу \code{BitSequenceFile}:}\\\indent

Реалізація класу \code{BitSequenceFile} аналогічна реалізації в завданні 2, з виправленням деяких помилок.\\\indent

\textbf{Реалізація класу \code{ByteCounter}:}\\\indent

Мета класу -- порахувати байти. Отримує на вхід шлях файла, рахує байти в ньому та повертає словник виду \code{\{byte: n\_encountered\}}. За потреби, результат роботи лічильника бути представлений в консолі у вигляді таблиці

\textbf{Реалізація класу \code{HuffmanTree}:}\\\indent

Клас на вхід приймає \code{source}. Якщо це представник класу \code{ByteCounter} -- будується дерево Хаффмана на основі лічильника. Інакше -- клас створюється пустим та не готовим до роботи (необхідно для побудови дерева декодером).\\\indent
Перелік методів класу \code{HuffmanTree}:
\begin{itemize}
    \item \textbf{\code{\_\_init\_\_(source)}} -- ініціалізує клас, якщо отримано лічильник -- будує дерево;
    \item \textbf{\code{build(recount = True)}} -- будує дерево, якщо \code{recount} -- викликає перерахунок лічильника. Дерево будується наступним чином:\\\indent
        Cтворюється два словники виду \code{key: \{n\_encountered, left\_child\_key, right\_child\_key, parent\_key\}}, один словник містить усі вершини дерева, другий містить вершини що ще не були з'єднанні. \code{key} відповідає значенню байта для листків, або лежить в діапазоні 256-511 для вершин рощгалужень.\\\indent
        Допоки існують необ'єднанні вершини -- обрати дві необ'єднанні вершини з найменшою сумарною вагою та об'єднати. \code{key} останньої вершини запам'ятати як \code{self.tree\_key}.\\\indent
        Викликати \code{create\_encoding\_lookup} та \code{create\_decoding\_lookup};
    \item \textbf{\code{create\_encoding\_lookup()}} -- для кожного байта в списку вершин будує маршрут до кореня, шляхом переходу до батьківських вершин. Запам'ятовує бітовий рядок маршрута в словнику \code{encoding\_lookup} виду \code{\{byte: BitArray\}}. Байти що не зустрічались жодного разу у словнику видаляються;
    \item \textbf{\code{encode(object)}} -- побайтово знаходить відповідний байту бітовий рядок в \code{encoding\_lookup}. Повертає бітовий рядок що відповідає коду Хаффмана для усіх вхідних байтів;
    \item \textbf{\code{create\_decoding\_lookup()}} -- розвертає \code{encoding\_lookup} для утворення \code{decoding\_lookup} вигляду \code{\{BitArray: byte\}};
    \item \textbf{\code{decode(bit\_array, prog = False)}} -- декодує бітовий рядок. Якщо \code{prog} -- виводить прогресбар. Декодер побітово записує вхідний рядок в буфер (що є представником класу BitArray), якщо буфер є ключем в \code{decoding\_lookup} -- записує відповідний байт у вихідний \code{bytearray}. Після обробки усіх бітів -- повертає масив байтів;
    \item \textbf{\code{store()}} -- зберігає дерево у бітовий рядок наступного виду: перший байт -- кількість розгалужень у дереві, наступні 4 $\cdot$ *кількість розгалужень* байтів містять \code{key} лівої дитини (в двох перших байтах) та правої дитини (в тертьому та четвертому байтах). Теоретично можна вмістити ключі дітей в 18 біт, але усі спроби це реалізувати були невдалими.
\end{itemize}

\textbf{Реалізація кодування файлів:}\\\indent

На вхід приймається шлях файлу, бажаний шлях закодованого файлу (якщо такий відсутній, до поточного шляху файла дописується \code{.huff}) та розмір кроку з яким читати файл. Рахується кількість байтів у файлі, створюється дерево, дерево зберігається через \code{store()} в перших байтах файла, після чого файл читається та кодується кроками (за замовчуванням 1024 байта), результат кодування кроку одразу ж записується в файл (якщо файл не кратний довжині кроку -- останній крок буде коротшим, щоб це врахувати). Після кодування додається ще один байт, в якому записано вказівник на перший невикористаний біт в останньому байті, оскільки довжина закодованої бітової послідовності може бути не кратна восьми.

\textbf{Реалізація декодування файлів:}\\\indent

На вхід приймається шлях файлу, бажаний шлях декодованого файлу (якщо такий відсутній, з поточного шляху файла видаляється \code{.huff} (звісно ж, якщо це закінчення там присутнє)). Декодер читає кількість розгалужень в першому байті, читає інформацію про розгалуження в наступних 4 $\cdot$ *кількість розгалужень* байтах та записує її в список вершин, ходить по кожному розгалуженню і прописує його дітям \code{key} батька, якщо дитина це байт -- створює його у списку вершин, шукає корінь, записує список вершин та корінь в дерево та запускає \code{create\_encoding\_lookup()} і \code{create\_decoding\_lookup()}. Після цього читається вказівник у останньому байті, читається бітовий рядок між метаданими на початку файлу та останнім байтом, цей бітовий рядок декодується та результат записується в файл.\\\indent

\newpage
\textbf{Аналіз метаданих:}\\\indent

В завданні наведено приклад метаданих що завжди займає 1024 байти. Імплементований варіант в найгіршому випадку використовує 2 байти + 4 байти на кожне розгалуження (для алфавіту довжиною 256 кількість розгалужень 255), тобто 1020 байтів. Для текстових файлів цей показник ближчий до 400 байт.\\\indent
Якщо ж використовувати на кожне розгалуження не 4 байти, а 18 біт запропонованого варіанту, то в найгіршому випадку буде використовуватись 575 байт 6 біт.\\\indent

\textbf{Аналіз стиснення:}\\\indent

Для аналізу стиснення обрано наступні типи файлів: \code{.txt, .stl, .jpg, .mp3, .wav, .pdf, .mp4, .docx}. Обрано по 10 файлів для кожного типу. Оскільки обрані файли мають розміри значно більші за 1КБ (максимальний розмір метаданих), то коефіцієнт стиснення завжди буде рахуватись без відкидання метаданих з довжини файлу


\textbf{Посилання на код на GitHub:}\\
\code{https://github.com/MINIAProgramStudio/algorythms\_of\_data\_transformation/tree/main/task3}
\end{document}